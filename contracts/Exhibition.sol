//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.9;

import "hardhat/console.sol";
import "./IERC721.sol";
import "./Ownable.sol";
// don't know if you need to import PortalController here if PortalGenerator already imports it
import "./PortalController.sol";
import "./PortalGenerator.sol";

contract CureoExhibition is Ownable, PortalGenerator {

    // TODO
    // 1. listing period
    // 2. commission
    // 3. events
    // 4. cleanup

    // Prefix command for differentiating between future kinds of listings
    bytes32 internal constant CMD_FIXED_LISTING = keccak256('fixed-listing');

    uint256 private commissionPercent;
    uint256 startTime;
    uint256 salePeriod;
    bool started;

    constructor(uint256 commissionPercentage_, uint256 salePeriod_) {
        require(commissionPercent <= 100, "invalid commission");
        require(salePeriod <= 604800, "4 weeks maximum sale period");

        commissionPercent = commissionPercentage_;
        salePeriod = salePeriod_;
        started = false;
    }

    function start() external onlyOwner {
        startTime = block.timestamp;
        started = true;
    }

    // CAN PROBABLY REFACTOR TO DECLARE PARAMS FOR THIS PORTAL TYPE
    // struct Portal_params {
    //     address payable sellerAddress,
    //     address tokenAddress,
    //     uint256 tokenID,
    //     uint256 price 
    // }

    function generateAddress(
        bytes32 salt, // entropy generated by curator that creates the listing
        // Portal_params portalParams
        address payable sellerAddress,
        address tokenAddress,
        uint256 tokenID,
        uint256 price
    ) external view returns (address) {
        bytes memory data = abi.encode(
            sellerAddress, 
            tokenAddress, 
            tokenID, 
            price
        );
        return _portalAddress(_create2Salt(salt, data));
    }

    // user and gallery need salt to control any tokens at listingAddress
    function buy(
        bytes32 salt,
        // Portal_params portalParams
        address payable sellerAddress,
        address tokenAddress,
        uint256 tokenID,
        uint256 price
    ) external payable {
        // can use >= because controller contract will refund the payment
        require(started, "exhibition not started");
        require(block.timestamp < startTime + salePeriod, "exhibition over");
        // are they only able to pay using ETH? Should I try adding ERC20 functionality too?
        require(msg.value >= price, "insufficient payment");

        // build calldata object for IERC721.transferFrom()
        bytes memory data = abi.encode(sellerAddress, tokenAddress, tokenID, price);

        PortalController portalController = new PortalController{
        salt: _create2Salt(salt, data)
        }();

        // buy parameters must match listing parameters used to create listing address for execution
        // on the PortalController to succeed
        if (
            !_execute(
                portalController, 
                tokenAddress, 
                0, 
                abi.encodeWithSelector(
                    IERC721.transferFrom.selector,
                    address(portalController),   // from
                    msg.sender,                 // to
                    tokenID
                )
            )
        ) revert ("transferFrom failed");

        // todo: use safe math to handle overflow
        uint256 commission = price * commissionPercent / 100;

        (bool paidCurator,) = owner.call{value: commission}("");
        if(!paidCurator) revert("failed to pay curator");

        (bool paidSeller,) = sellerAddress.call{value: price - commission}("");
        if(!paidSeller) revert("failed to pay seller");

        // don't pay contract storage costs
        portalController.destroy(msg.sender);
    }

    // sellerAddress: original seller to refund to
    // todo: rename to reclaim
    function refund(
        bytes32 salt, 
        // Portal_params portalParams
        address sellerAddress, 
        address tokenAddress, 
        uint256 tokenID, 
        uint256 price
    )
    external {
        require(!started || block.timestamp > startTime + salePeriod, "exhibition in progress");

        bytes memory data = abi.encode(sellerAddress, tokenAddress, tokenID, price);

        // instantiate controller contract to listingAddress address
        PortalController portalController = new PortalController{
        salt: _create2Salt(salt, data)
        }();

        // transfer token from portalController to seller
        if (
            !_execute(
                portalController, 
                tokenAddress, 
                0, 
                abi.encodeWithSelector(
                    IERC721.transferFrom.selector,
                    address(portalController),   // from
                    sellerAddress,              // to
                    tokenID
                )
            )
        ) revert ("refund failed");


        // NOTE: `portalController` must always be destroyed in the same runtime context that it is deployed.
        portalController.destroy(address(this));
    }
}